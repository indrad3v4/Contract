# account_service.py - Properly retrieve account information

from cosmpy.aerial.client import LedgerClient, NetworkConfig
from cosmpy.aerial.wallet import LocalWallet
from cosmpy.crypto.address import Address

class AccountService:
    def __init__(self):
        self.network = NetworkConfig(
            chain_id="odiseotestnet_1234-1",
            url="https://rpc.odiseotestnet_1234-1.com",  # Replace with actual testnet RPC URL
            fee_minimum_gas_price=0.025,
            fee_denomination="uodc",  # Replace with actual denomination
            staking_denomination="uodc"
        )
        self.client = LedgerClient(self.network)
    
    def get_account_data(self, address):
        """Get account number and sequence for an address"""
        try:
            account_data = self.client.query_account(Address(address))
            return {
                "account_number": str(account_data.account_number),
                "sequence": str(account_data.sequence)
            }
        except Exception as e:
            return {"error": f"Failed to get account data: {str(e)}"}


# transaction_service.py - Create and broadcast transactions

from cosmpy.aerial.tx import Transaction
from cosmpy.aerial.client import LedgerClient, NetworkConfig
from cosmpy.aerial.tx_helpers import SubmittedTx
import json
import base64

class TransactionService:
    def __init__(self):
        self.network = NetworkConfig(
            chain_id="odiseotestnet_1234-1",
            url="https://rpc.odiseotestnet_1234-1.com",  # Replace with actual testnet RPC URL
            fee_minimum_gas_price=0.025,
            fee_denomination="uodc",
            staking_denomination="uodc"
        )
        self.client = LedgerClient(self.network)
    
    def create_sign_doc(self, sender_address, msg, account_data=None):
        """Create a sign doc for Keplr to sign"""
        if account_data is None:
            # Get account data from chain
            try:
                account = self.client.query_account(Address(sender_address))
                account_number = account.account_number
                sequence = account.sequence
            except Exception as e:
                return {"error": f"Failed to get account data: {str(e)}"}
        else:
            account_number = int(account_data.get("account_number", "0"))
            sequence = int(account_data.get("sequence", "0"))
        
        # Create transaction with proper values
        tx = Transaction()
        tx.chain_id = self.network.chain_id
        
        # Add message to transaction
        # This example assumes msg is properly formatted for the chain
        tx.add_message(msg)
        
        # Set proper gas and fees
        tx.gas_limit = 200000  # Adjust based on transaction complexity
        tx.fee = [{"denom": self.network.fee_denomination, "amount": "5000"}]
        
        # Create sign doc
        sign_doc = tx.get_sign_doc(account_number, sequence)
        return {
            "sign_doc": sign_doc,
            "account_number": str(account_number),
            "sequence": str(sequence)
        }
    
    def broadcast_signed_tx(self, signed_tx_data):
        """Broadcast a signed transaction to the network"""
        try:
            # Parse the signed transaction data from frontend
            tx_raw = {
                "body": signed_tx_data["body"],
                "auth_info": signed_tx_data["auth_info"],
                "signatures": [base64.b64decode(sig) for sig in signed_tx_data["signatures"]]
            }
            
            # Create a submitted transaction and broadcast
            submitted_tx = SubmittedTx(tx_raw, self.client)
            result = submitted_tx.wait_to_complete()
            
            return {
                "success": True,
                "tx_hash": result.tx_hash,
                "code": result.code,
                "raw_log": result.raw_log
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to broadcast transaction: {str(e)}"
            }


# api_routes.py - API endpoints for the transaction flow

from flask import Blueprint, request, jsonify
from .account_service import AccountService
from .transaction_service import TransactionService

api = Blueprint('api', __name__)
account_service = AccountService()
transaction_service = TransactionService()

@api.route('/api/account', methods=['GET'])
def get_account_data():
    address = request.args.get('address')
    if not address:
        return jsonify({"error": "Address parameter is required"}), 400
    
    return jsonify(account_service.get_account_data(address))

@api.route('/api/sign', methods=['POST'])
def create_sign_request():
    data = request.json
    if not data or 'address' not in data or 'msg' not in data:
        return jsonify({"error": "Address and message are required"}), 400
    
    # Get fresh account data for accurate sequence
    account_data = account_service.get_account_data(data['address'])
    if "error" in account_data:
        return jsonify(account_data), 400
    
    # Create sign doc with proper account number and sequence
    sign_doc_result = transaction_service.create_sign_doc(
        data['address'], 
        data['msg'],
        account_data
    )
    
    if "error" in sign_doc_result:
        return jsonify(sign_doc_result), 400
    
    return jsonify(sign_doc_result)

@api.route('/api/broadcast', methods=['POST'])
def broadcast_transaction():
    data = request.json
    if not data:
        return jsonify({"error": "No transaction data provided"}), 400
    
    result = transaction_service.broadcast_signed_tx(data)
    return jsonify(result), 200 if result.get('success') else 400

@api.route('/api/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    
    # Save file logic here
    # ...
    
    # Create message for the transaction
    # This is a simplified example - adjust based on your contract structure
    msg = {
        "typeUrl": "/cosmos.bank.v1beta1.MsgSend",  # Or your custom contract message type
        "value": {
            # Your message value based on file upload and tokenization logic
            # ...
        }
    }
    
    return jsonify({
        "success": True,
        "msg": msg,
        "message": "File uploaded successfully, proceed with signing"
    })