# src/services/transaction_service.py

import requests
import logging
import json
from config import get_config

logger = logging.getLogger(__name__)

class TransactionService:
    def __init__(self):
        self.config = get_config()
        self.rpc_url = self.config.get("BLOCKCHAIN_RPC_URL", "https://rpc.odiseotestnet.com")
        self.broadcast_endpoint = f"{self.rpc_url}/broadcast_tx_commit"
    
    def broadcast_transaction(self, tx_data):
        """
        Broadcast a signed transaction to the blockchain
        
        Args:
            tx_data (dict): The transaction data including signatures
            
        Returns:
            dict: The response from the blockchain
        """
        try:
            logger.info(f"Broadcasting transaction to {self.broadcast_endpoint}")
            
            # Convert the transaction to the format expected by Tendermint RPC
            # This varies based on the specific blockchain implementation
            
            # For standard Tendermint RPC, we need to encode the transaction
            tx_encoded = self._encode_transaction(tx_data)
            
            # Make the RPC call
            response = requests.post(
                self.broadcast_endpoint,
                json={"jsonrpc": "2.0", "id": 1, "method": "broadcast_tx_commit", "params": [tx_encoded]}
            )
            
            if response.status_code != 200:
                logger.error(f"RPC error: {response.status_code} - {response.text}")
                raise ValueError(f"RPC returned error: {response.text}")
            
            result = response.json()
            
            # Check for errors in the response
            if "error" in result and result["error"]:
                logger.error(f"Transaction error: {result['error']}")
                raise ValueError(f"Blockchain error: {result['error']}")
            
            # Extract and return the result
            tx_result = result.get("result", {})
            logger.info(f"Transaction broadcast successful. Hash: {tx_result.get('hash')}")
            
            return {
                "txhash": tx_result.get("hash"),
                "height": tx_result.get("height"),
                "code": tx_result.get("check_tx", {}).get("code", 0),
                "raw_log": tx_result.get("deliver_tx", {}).get("log", "")
            }
            
        except Exception as e:
            logger.error(f"Error broadcasting transaction: {str(e)}", exc_info=True)
            raise ValueError(f"Failed to broadcast transaction: {str(e)}")
    
    def _encode_transaction(self, tx_data):
        """
        Encode transaction for the blockchain RPC
        
        Different blockchains might require different encoding formats.
        This is a simplified example for Cosmos SDK.
        
        Args:
            tx_data (dict): The transaction data
            
        Returns:
            str: Encoded transaction
        """
        try:
            # Convert the transaction to a standard format
            # For Cosmos SDK, we typically need the full StdTx format
            std_tx = {
                "msg": tx_data["tx"]["msg"],
                "fee": tx_data["tx"]["fee"],
                "signatures": tx_data["tx"]["signatures"],
                "memo": tx_data["tx"]["memo"]
            }
            
            # Convert to JSON and then base64 encode
            # This may vary depending on your specific blockchain
            import base64
            tx_json = json.dumps(std_tx)
            tx_bytes = tx_json.encode('utf-8')
            tx_encoded = base64.b64encode(tx_bytes).decode('utf-8')
            
            return tx_encoded
        
        except Exception as e:
            logger.error(f"Error encoding transaction: {str(e)}", exc_info=True)
            raise ValueError(f"Failed to encode transaction: {str(e)}")
            
    def get_account_data(self, address):
        """
        Get account data from the blockchain
        
        Args:
            address (str): The account address
            
        Returns:
            dict: Account data including sequence and account_number
        """
        try:
            # Query the account endpoint
            account_url = f"{self.rpc_url}/auth/accounts/{address}"
            logger.info(f"Querying account data from {account_url}")
            
            response = requests.get(account_url)
            
            if response.status_code != 200:
                logger.error(f"RPC error: {response.status_code} - {response.text}")
                raise ValueError(f"Failed to get account data: {response.text}")
            
            result = response.json()
            
            # Extract the relevant account data
            account = result.get("result", {}).get("value", {})
            
            # Format the response
            return {
                "address": address,
                "account_number": str(account.get("account_number", "0")),
                "sequence": str(account.get("sequence", "0"))
            }
        
        except Exception as e:
            logger.error(f"Error getting account data: {str(e)}", exc_info=True)
            raise ValueError(f"Failed to get account data: {str(e)}")