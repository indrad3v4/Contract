[Skip to main content](https://docs.cosmos.network/main/learn/advanced/transactions#docusaurus_skipToContent_fallback)

This is unreleased documentation for Explore the SDK **Next** version.

For up-to-date documentation, see the **[latest version](https://docs.cosmos.network/v0.52/learn/advanced/transactions)** (v0.52).

Version: Next

On this page

# Transactions

Synopsis

`Transactions` are objects created by end-users to trigger state changes in the application.

Pre-requisite Readings

- [Anatomy of a Cosmos SDK Application](https://docs.cosmos.network/main/learn/beginner/app-anatomy)

## Transactions [​](https://docs.cosmos.network/main/learn/advanced/transactions\#transactions-1 "Direct link to Transactions")

Transactions are comprised of metadata held in [contexts](https://docs.cosmos.network/main/learn/advanced/context) and [`sdk.Msg` s](https://docs.cosmos.network/main/build/building-modules/messages-and-queries) that trigger state changes within a module through the module's Protobuf [`Msg` service](https://docs.cosmos.network/main/build/building-modules/msg-services).

When users want to interact with an application and make state changes (e.g. sending coins), they create transactions. Each of a transaction's `sdk.Msg` must be signed using the private key associated with the appropriate account(s), before the transaction is broadcasted to the network. A transaction must then be included in a block, validated, and approved by the network through the consensus process. To read more about the lifecycle of a transaction, click [here](https://docs.cosmos.network/main/learn/beginner/tx-lifecycle).

## Type Definition [​](https://docs.cosmos.network/main/learn/advanced/transactions\#type-definition "Direct link to Type Definition")

Transaction objects are Cosmos SDK types that implement the `Tx` interface

types/tx\_msg.go

```codeBlockLines_e6Vv
// Tx defines an interface a transaction must fulfill.
Tx interface {
	transaction.Tx

	HasMsgs

	// GetReflectMessages gets a reflected version of the transaction's messages
	// that can be used by dynamic APIs. These messages should not be used for actual
	// processing as they cannot be guaranteed to be what handlers are expecting, but
	// they can be used for dynamically reading specific fields from the message such
	// as signers or validation data. Message processors should ALWAYS use the messages
	// returned by GetMsgs.
	GetReflectMessages() ([]protoreflect.Message, error)
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/types/tx_msg.go#L53-L66)

It contains the following methods:

- **GetMsgs:** unwraps the transaction and returns a list of contained `sdk.Msg` s - one transaction may have one or multiple messages, which are defined by module developers.
- **ValidateBasic:** lightweight, [_stateless_](https://docs.cosmos.network/main/learn/beginner/tx-lifecycle#types-of-checks) checks used by ABCI messages [`CheckTx`](https://docs.cosmos.network/main/learn/advanced/baseapp#checktx) and [`RunTx`](https://docs.cosmos.network/main/learn/advanced/baseapp#runtx) to make sure transactions are not invalid. For example, the [`auth`](https://github.com/cosmos/cosmos-sdk/tree/main/x/auth) module's `ValidateBasic` function checks that its transactions are signed by the correct number of signers and that the fees do not exceed the user's maximum. When [`runTx`](https://docs.cosmos.network/main/learn/advanced/baseapp#runtx) is checking a transaction created from the [`auth`](https://github.com/cosmos/cosmos-sdk/tree/main/x/auth/) module, it first runs `ValidateBasic` on each message, then runs the `auth` module AnteHandler which calls `ValidateBasic` for the transaction itself.
- **Hash()**: returns the unique identifier for the Tx.
- **GetMessages:** returns the list of `sdk.Msg` s contained in the transaction.
- **GetSenders:** returns the addresses of the signers who signed the transaction.
- **GetGasLimit:** returns the gas limit for the transaction. Returns `math.MaxUint64` for transactions with unlimited gas.
- **Bytes:** returns the encoded bytes of the transaction. This is typically cached after the first decoding of the transaction.

note

This function is different from the deprecated `sdk.Msg` [`ValidateBasic`](https://docs.cosmos.network/main/learn/beginner/tx-lifecycle#ValidateBasic) methods, which was performing basic validity checks on messages only.

As a developer, you should rarely manipulate `Tx` directly, as `Tx` is really an intermediate type used for transaction generation. Instead, developers should prefer the `TxBuilder` interface, which you can learn more about [below](https://docs.cosmos.network/main/learn/advanced/transactions#transaction-generation).

### Signing Transactions [​](https://docs.cosmos.network/main/learn/advanced/transactions\#signing-transactions "Direct link to Signing Transactions")

Every message in a transaction must be signed by the addresses specified by its `GetSigners`. The Cosmos SDK currently allows signing transactions in two different ways.

#### `SIGN_MODE_DIRECT` (preferred) [​](https://docs.cosmos.network/main/learn/advanced/transactions\#sign_mode_direct-preferred "Direct link to sign_mode_direct-preferred")

The most used implementation of the `Tx` interface is the Protobuf `Tx` message, which is used in `SIGN_MODE_DIRECT`:

proto/cosmos/tx/v1beta1/tx.proto

```codeBlockLines_e6Vv
// Tx is the standard type used for broadcasting transactions.
message Tx {
  // body is the processable content of the transaction
  TxBody body = 1;

  // auth_info is the authorization related content of the transaction,
  // specifically signers, signer modes and fee
  AuthInfo auth_info = 2;

  // signatures is a list of signatures that matches the length and order of
  // AuthInfo's signer_infos to allow connecting signature meta information like
  // public key and signing mode by position.
  repeated bytes signatures = 3;
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/proto/cosmos/tx/v1beta1/tx.proto#L15-L28)

Because Protobuf serialization is not deterministic, the Cosmos SDK uses an additional `TxRaw` type to denote the pinned bytes over which a transaction is signed. Any user can generate a valid `body` and `auth_info` for a transaction, and serialize these two messages using Protobuf. `TxRaw` then pins the user's exact binary representation of `body` and `auth_info`, called respectively `body_bytes` and `auth_info_bytes`. The document that is signed by all signers of the transaction is `SignDoc` (deterministically serialized using [ADR-027](https://docs.cosmos.network/main/architecture/adr-027-deterministic-protobuf-serialization.md)):

proto/cosmos/tx/v1beta1/tx.proto

```codeBlockLines_e6Vv
// SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
message SignDoc {
  // body_bytes is protobuf serialization of a TxBody that matches the
  // representation in TxRaw.
  bytes body_bytes = 1;

  // auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  // representation in TxRaw.
  bytes auth_info_bytes = 2;

  // chain_id is the unique identifier of the chain this transaction targets.
  // It prevents signed transactions from being used on another chain by an
  // attacker
  string chain_id = 3;

  // account_number is the account number of the account in state
  uint64 account_number = 4;
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/proto/cosmos/tx/v1beta1/tx.proto#L50-L67)

Once signed by all signers, the `body_bytes`, `auth_info_bytes` and `signatures` are gathered into `TxRaw`, whose serialized bytes are broadcasted over the network.

#### `SIGN_MODE_LEGACY_AMINO_JSON` [​](https://docs.cosmos.network/main/learn/advanced/transactions\#sign_mode_legacy_amino_json "Direct link to sign_mode_legacy_amino_json")

The legacy implementation of the `Tx` interface is the `StdTx` struct from `x/auth`:

x/auth/migrations/legacytx/stdtx.go

```codeBlockLines_e6Vv
// StdTx is the legacy transaction format for wrapping a Msg with Fee and Signatures.
// It only works with Amino, please prefer the new protobuf Tx in types/tx.
// NOTE: the first signature is the fee payer (Signatures must not be nil).
// Deprecated
type StdTx struct {
	Msgs          []sdk.Msg      `json:"msg" yaml:"msg"`
	Fee           StdFee         `json:"fee" yaml:"fee"`
	Signatures    []StdSignature `json:"signatures" yaml:"signatures"`
	Memo          string         `json:"memo" yaml:"memo"`
	TimeoutHeight uint64         `json:"timeout_height" yaml:"timeout_height"`
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/x/auth/migrations/legacytx/stdtx.go#L81-L91)

The document signed by all signers is `StdSignDoc`:

x/auth/migrations/legacytx/stdsign.go

```codeBlockLines_e6Vv
// StdSignDoc is replay-prevention structure.
// It includes the result of msg.GetSignBytes(),
// as well as the ChainID (prevent cross chain replay)
// and the Sequence numbers for each signature (prevent
// inchain replay and enforce tx ordering per account).
type StdSignDoc struct {
	AccountNumber uint64            `json:"account_number" yaml:"account_number"`
	Sequence      uint64            `json:"sequence" yaml:"sequence"`
	TimeoutHeight uint64            `json:"timeout_height,omitempty" yaml:"timeout_height"`
	ChainID       string            `json:"chain_id" yaml:"chain_id"`
	Memo          string            `json:"memo" yaml:"memo"`
	Fee           json.RawMessage   `json:"fee" yaml:"fee"`
	Msgs          []json.RawMessage `json:"msgs" yaml:"msgs"`
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/x/auth/migrations/legacytx/stdsign.go#L32-L45)

which is encoded into bytes using Amino JSON. Once all signatures are gathered into `StdTx`, `StdTx` is serialized using Amino JSON, and these bytes are broadcasted over the network.

#### Other Sign Modes [​](https://docs.cosmos.network/main/learn/advanced/transactions\#other-sign-modes "Direct link to Other Sign Modes")

The Cosmos SDK also provides a couple of other sign modes for particular use cases.

#### `SIGN_MODE_DIRECT_AUX` [​](https://docs.cosmos.network/main/learn/advanced/transactions\#sign_mode_direct_aux "Direct link to sign_mode_direct_aux")

`SIGN_MODE_DIRECT_AUX` is a sign mode released in the Cosmos SDK v0.46 which targets transactions with multiple signers. Whereas `SIGN_MODE_DIRECT` expects each signer to sign over both `TxBody` and `AuthInfo` (which includes all other signers' signer infos, i.e. their account sequence, public key and mode info), `SIGN_MODE_DIRECT_AUX` allows N-1 signers to only sign over `TxBody` and _their own_ signer info. Moreover, each auxiliary signer (i.e. a signer using `SIGN_MODE_DIRECT_AUX`) doesn't
need to sign over the fees:

proto/cosmos/tx/v1beta1/tx.proto

```codeBlockLines_e6Vv
// SignDocDirectAux is the type used for generating sign bytes for
// SIGN_MODE_DIRECT_AUX.
message SignDocDirectAux {
  option (cosmos_proto.message_added_in) = "cosmos-sdk 0.46";
  // body_bytes is protobuf serialization of a TxBody that matches the
  // representation in TxRaw.
  bytes body_bytes = 1;

  // public_key is the public key of the signing account.
  google.protobuf.Any public_key = 2;

  // chain_id is the identifier of the chain this transaction targets.
  // It prevents signed transactions from being used on another chain by an
  // attacker.
  string chain_id = 3;

  // account_number is the account number of the account in state.
  uint64 account_number = 4;

  // sequence is the sequence number of the signing account.
  uint64 sequence = 5;

  // tips have been deprecated and should not be used
  Tip tip = 6 [deprecated = true];
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/proto/cosmos/tx/v1beta1/tx.proto#L69-L93)

The use case is a multi-signer transaction, where one of the signers is appointed to gather all signatures, broadcast the signature and pay for fees, and the others only care about the transaction body. This generally allows for a better multi-signing UX. If Alice, Bob and Charlie are part of a 3-signer transaction, then Alice and Bob can both use `SIGN_MODE_DIRECT_AUX` to sign over the `TxBody` and their own signer info (no need an additional step to gather other signers' ones, like in `SIGN_MODE_DIRECT`), without specifying a fee in their SignDoc. Charlie can then gather both signatures from Alice and Bob, and
create the final transaction by appending a fee. Note that the fee payer of the transaction (in our case Charlie) must sign over the fees, so must use `SIGN_MODE_DIRECT` or `SIGN_MODE_LEGACY_AMINO_JSON`.

#### `SIGN_MODE_TEXTUAL` [​](https://docs.cosmos.network/main/learn/advanced/transactions\#sign_mode_textual "Direct link to sign_mode_textual")

`SIGN_MODE_TEXTUAL` is a new sign mode for delivering a better signing experience on hardware wallets and it is included in the v0.50 release. In this mode, the signer signs over the human-readable string representation of the transaction (CBOR) and makes all data being displayed easier to read. The data is formatted as screens, and each screen is meant to be displayed in its entirety even on small devices like the Ledger Nano.

There are also _expert_ screens, which will only be displayed if the user has chosen that option in its hardware device. These screens contain things like account number, account sequence and the sign data hash.

Data is formatted using a set of `ValueRenderer` which the SDK provides defaults for all the known messages and value types. Chain developers can also opt to implement their own `ValueRenderer` for a type/message if they'd like to display information differently.

If you wish to learn more, please refer to [ADR-050](https://docs.cosmos.network/main/architecture/adr-050-sign-mode-textual.md).

#### Custom Sign modes [​](https://docs.cosmos.network/main/learn/advanced/transactions\#custom-sign-modes "Direct link to Custom Sign modes")

There is the opportunity to add your own custom sign mode to the Cosmos-SDK. While we can not accept the implementation of the sign mode to the repository, we can accept a pull request to add the custom signmode to the SignMode enum located [here](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/proto/cosmos/tx/signing/v1beta1/signing.proto#L9-L17)

## Transaction Process [​](https://docs.cosmos.network/main/learn/advanced/transactions\#transaction-process "Direct link to Transaction Process")

The process of an end-user sending a transaction is:

- decide on the messages to put into the transaction,
- generate the transaction using the Cosmos SDK's `TxBuilder`,
- broadcast the transaction using one of the available interfaces.

The next paragraphs will describe each of these components, in this order.

### Messages [​](https://docs.cosmos.network/main/learn/advanced/transactions\#messages "Direct link to Messages")

tip

Module `sdk.Msg` s are not to be confused with [ABCI Messages](https://docs.cometbft.com/v1.0/spec/abci/) which define interactions between the CometBFT and application layers.

**Messages** (or `sdk.Msg` s) are module-specific objects that trigger state transitions within the scope of the module they belong to. Module developers define the messages for their module by adding methods to the Protobuf [`Msg` service](https://docs.cosmos.network/main/build/building-modules/msg-services), and also implement the corresponding `MsgServer`.

Each `sdk.Msg` s is related to exactly one Protobuf [`Msg` service](https://docs.cosmos.network/main/build/building-modules/msg-services) RPC, defined inside each module's `tx.proto` file. A SDK app router automatically maps every `sdk.Msg` to a corresponding RPC. Protobuf generates a `MsgServer` interface for each module `Msg` service, and the module developer needs to implement this interface.
This design puts more responsibility on module developers, allowing application developers to reuse common functionalities without having to implement state transition logic repetitively.

To learn more about Protobuf `Msg` services and how to implement `MsgServer`, click [here](https://docs.cosmos.network/main/build/building-modules/msg-services).

While messages contain the information for state transition logic, a transaction's other metadata and relevant information are stored in the `TxBuilder` and `Context`.

### Transaction Generation [​](https://docs.cosmos.network/main/learn/advanced/transactions\#transaction-generation "Direct link to Transaction Generation")

The `TxBuilder` interface contains data closely related with the generation of transactions, which an end-user can freely set to generate the desired transaction:

client/tx\_config.go

```codeBlockLines_e6Vv
// TxBuilder defines an interface which an application-defined concrete transaction
// type must implement. Namely, it must be able to set messages, generate
// signatures, and provide canonical bytes to sign over. The transaction must
// also know how to encode itself.
TxBuilder interface {
	GetTx() signing.Tx

	SetMsgs(msgs ...sdk.Msg) error
	SetSignatures(signatures ...signingtypes.SignatureV2) error
	SetMemo(memo string)
	SetFeeAmount(amount sdk.Coins)
	SetFeePayer(feePayer sdk.AccAddress)
	SetGasLimit(limit uint64)
	SetTimeoutHeight(height uint64)
	SetTimeoutTimestamp(timestamp time.Time)
	SetUnordered(v bool)
	SetFeeGranter(feeGranter sdk.AccAddress)
	AddAuxSignerData(tx.AuxSignerData) error
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/client/tx_config.go#L39-L57)

- `Msg` s, the array of [messages](https://docs.cosmos.network/main/learn/advanced/transactions#messages) included in the transaction.
- `GasLimit`, option chosen by the users for how to calculate how much gas they will need to pay.
- `Memo`, a note or comment to send with the transaction.
- `FeeAmount`, the maximum amount the user is willing to pay in fees.
- `TimeoutHeight`, block height until which the transaction is valid.
- `TimeoutTimestamp`, timestamp until which the transaction is valid.
- `Unordered`, whether transactions can be executed in any order. Nonce is then unevaluated (NOTE: A timeout timestamp must be set if `Unordered` is true).
- `Signatures`, the array of signatures from all signers of the transaction.

As there are currently two sign modes for signing transactions, there are also two implementations of `TxBuilder`:

- [builder](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/x/auth/tx/builder.go#L79-L98) for creating transactions for `SIGN_MODE_DIRECT`,
- [StdTxBuilder](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/x/auth/migrations/legacytx/stdtx_builder.go#L11-L17) for `SIGN_MODE_LEGACY_AMINO_JSON`.

However, the two implementations of `TxBuilder` should be hidden away from end-users, as they should prefer using the overarching `TxConfig` interface:

client/tx\_config.go

```codeBlockLines_e6Vv
// TxConfig defines an interface a client can utilize to generate an
// application-defined concrete transaction type. The type returned must
// implement TxBuilder.
TxConfig interface {
	TxEncodingConfig

	NewTxBuilder() TxBuilder
	WrapTxBuilder(sdk.Tx) (TxBuilder, error)
	SignModeHandler() *txsigning.HandlerMap
	SigningContext() *txsigning.Context
}

```

[See full example on GitHub](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/client/tx_config.go#L27-L37)

`TxConfig` is an app-wide configuration for managing transactions. Most importantly, it holds the information about whether to sign each transaction with `SIGN_MODE_DIRECT` or `SIGN_MODE_LEGACY_AMINO_JSON`. By calling `txBuilder := txConfig.NewTxBuilder()`, a new `TxBuilder` will be created with the appropriate sign mode.

Once `TxBuilder` is correctly populated with the setters exposed above, `TxConfig` will also take care of correctly encoding the bytes (again, either using `SIGN_MODE_DIRECT` or `SIGN_MODE_LEGACY_AMINO_JSON`). Here's a pseudo-code snippet of how to generate and encode a transaction, using the `TxEncoder()` method:

```codeBlockLines_e6Vv
txBuilder := txConfig.NewTxBuilder()
txBuilder.SetMsgs(...) // and other setters on txBuilder

bz, err := txConfig.TxEncoder()(txBuilder.GetTx())
// bz are bytes to be broadcasted over the network

```

### Broadcasting the Transaction [​](https://docs.cosmos.network/main/learn/advanced/transactions\#broadcasting-the-transaction "Direct link to Broadcasting the Transaction")

Once the transaction bytes are generated, there are currently three ways of broadcasting it.

#### CLI [​](https://docs.cosmos.network/main/learn/advanced/transactions\#cli "Direct link to CLI")

Application developers create entry points to the application by creating a [command-line interface](https://docs.cosmos.network/main/learn/advanced/cli), [gRPC and/or REST interface](https://docs.cosmos.network/main/learn/advanced/grpc_rest), typically found in the application's `./cmd` folder. These interfaces allow users to interact with the application through command-line.

For the [command-line interface](https://docs.cosmos.network/main/build/building-modules/module-interfaces#cli), module developers create subcommands to add as children to the application top-level transaction command `TxCmd`. CLI commands actually bundle all the steps of transaction processing into one simple command: creating messages, generating transactions and broadcasting. For concrete examples, see the [Interacting with a Node](https://docs.cosmos.network/main/user/run-node/interact-node) section. An example transaction made using CLI looks like:

```codeBlockLines_e6Vv
simd tx send $MY_VALIDATOR_ADDRESS $RECIPIENT 1000stake

```

#### gRPC [​](https://docs.cosmos.network/main/learn/advanced/transactions\#grpc "Direct link to gRPC")

[gRPC](https://grpc.io/) is the main component for the Cosmos SDK's RPC layer. Its principal usage is in the context of modules' [`Query` services](https://docs.cosmos.network/main/build/building-modules/query-services). However, the Cosmos SDK also exposes a few other module-agnostic gRPC services, one of them being the `Tx` service:

[https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/proto/cosmos/tx/v1beta1/service.proto](https://github.com/cosmos/cosmos-sdk/blob/v0.52.0-beta.2/proto/cosmos/tx/v1beta1/service.proto)

The `Tx` service exposes a handful of utility functions, such as simulating a transaction or querying a transaction, and also one method to broadcast transactions.

Examples of broadcasting and simulating a transaction are shown [here](https://docs.cosmos.network/main/user/run-node/txs#programmatically-with-go).

#### REST [​](https://docs.cosmos.network/main/learn/advanced/transactions\#rest "Direct link to REST")

Each gRPC method has its corresponding REST endpoint, generated using [gRPC-gateway](https://github.com/grpc-ecosystem/grpc-gateway). Therefore, instead of using gRPC, you can also use HTTP to broadcast the same transaction, on the `POST /cosmos/tx/v1beta1/txs` endpoint.

An example can be seen [here](https://docs.cosmos.network/main/user/run-node/txs#using-rest)

#### CometBFT RPC [​](https://docs.cosmos.network/main/learn/advanced/transactions\#cometbft-rpc "Direct link to CometBFT RPC")

The three methods presented above are actually higher abstractions over the CometBFT RPC `/broadcast_tx_{async,sync,commit}` endpoints, documented [here](https://docs.cometbft.com/v1.0/explanation/core/rpc). This means that you can use the CometBFT RPC endpoints directly to broadcast the transaction, if you wish so.

- [Transactions](https://docs.cosmos.network/main/learn/advanced/transactions#transactions-1)
- [Type Definition](https://docs.cosmos.network/main/learn/advanced/transactions#type-definition)
  - [Signing Transactions](https://docs.cosmos.network/main/learn/advanced/transactions#signing-transactions)
- [Transaction Process](https://docs.cosmos.network/main/learn/advanced/transactions#transaction-process)
  - [Messages](https://docs.cosmos.network/main/learn/advanced/transactions#messages)
  - [Transaction Generation](https://docs.cosmos.network/main/learn/advanced/transactions#transaction-generation)
  - [Broadcasting the Transaction](https://docs.cosmos.network/main/learn/advanced/transactions#broadcasting-the-transaction)

[iframe](https://www.google.com/recaptcha/enterprise/anchor?ar=1&k=6Lck4YwlAAAAAEIE1hR--varWp0qu9F-8-emQn2v&co=aHR0cHM6Ly9kb2NzLmNvc21vcy5uZXR3b3JrOjQ0Mw..&hl=en&v=J79K9xgfxwT6Syzx-UyWdD89&size=invisible&cb=br6909ig2tb7)